#Order MCMC Algorithm
source("order_mcmc.R")
#evaluation metrics
source("skeleton_eval.R")
run_monte_carlo <- function(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.2) {
# Store results in a list
results <- list(PC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations)),
MCMC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations)))
for (i in 1:num_iterations) {
cat("Running iteration", i, "of", num_iterations, "\n")
#  Generate random DAG & sample data
sim_result <- simulate_GBN(num_nodes = num_nodes, num_samples = num_samples, edge_prob = edge_prob)
#  Run PC algorithm
pc_result <- run_PC_bnlearn(sim_result$data)
#  Run Order MCMC algorithm
mcmc_result <- run_order_mcmc(sim_result$data)
#  Evaluate performance (skeleton metrics)
eval_results <- evaluate_skeleton_performance(
true_dag = sim_result$dag,
pc_cpdag = pc_result$learned_cpdag,
mcmc_cpdag = mcmc_result$DAG
)
# Store metrics
results$PC$TPR[i] <- eval_results$PC$TPR
results$PC$FPR[i] <- eval_results$PC$FPR
results$PC$SHD[i] <- eval_results$PC$Skeleton_SHD
results$MCMC$TPR[i] <- eval_results$MCMC$TPR
results$MCMC$FPR[i] <- eval_results$MCMC$FPR
results$MCMC$SHD[i] <- eval_results$MCMC$Skeleton_SHD
}
return(results)
}
monte_carlo_results <- run_monte_carlo(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.15)
#Sample from Bayesian Network
source("data_sim.R")
monte_carlo_results <- run_monte_carlo(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.15)
warnings()
monte_carlo_results$PC$TPR
median(monte_carlo_results$PC$TPR)
median(monte_carlo_results$MCMC$TPR)
View(monte_carlo_results)
simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.2)$DAG
simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.2)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.2)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.2)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.2)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
plot(simulate_GBN(num_nodes = 10, num_samples = 500, edge_prob = 0.1)$dag)
monte_carlo_results
run_monte_carlo <- function(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.2) {
# Store results in a list
results <- list(
PC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations)),
MCMC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations), runtime = numeric(num_iterations))
)
for (i in 1:num_iterations) {
cat("Running iteration", i, "of", num_iterations, "\n")
# Generate random DAG & sample data
sim_result <- simulate_GBN(num_nodes = num_nodes, num_samples = num_samples, edge_prob = edge_prob)
# Run PC algorithm
pc_result <- run_PC_bnlearn(sim_result$data)
# Run Order MCMC algorithm (no need for manual timing)
mcmc_result <- run_order_mcmc(sim_result$data)
# Extract runtime from the MCMC output
runtime_mcmc <- mcmc_result$info$runtimes["total"]
# Evaluate performance (skeleton metrics)
eval_results <- evaluate_skeleton_performance(
true_dag = sim_result$dag,
pc_cpdag = pc_result$learned_cpdag,
mcmc_cpdag = mcmc_result$DAG
)
# Store metrics for PC
results$PC$TPR[i] <- eval_results$PC$TPR
results$PC$FPR[i] <- eval_results$PC$FPR
results$PC$SHD[i] <- eval_results$PC$Skeleton_SHD
# Store metrics for MCMC
results$MCMC$TPR[i] <- eval_results$MCMC$TPR
results$MCMC$FPR[i] <- eval_results$MCMC$FPR
results$MCMC$SHD[i] <- eval_results$MCMC$Skeleton_SHD
results$MCMC$runtime[i] <- runtime_mcmc  # Store MCMC runtime
}
return(results)
}
monte_carlo_results <- run_monte_carlo(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.15)
library(bnlearn)  # For DAG structure
library(igraph)
run_monte_carlo <- function(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.2) {
# Store results in a list
results <- list(
PC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations)),
MCMC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations), runtime = numeric(num_iterations))
)
for (i in 1:num_iterations) {
cat("Running iteration", i, "of", num_iterations, "\n")
# Generate random DAG & sample data
sim_result <- simulate_GBN(num_nodes = num_nodes, num_samples = num_samples, edge_prob = edge_prob)
# Run PC algorithm
pc_result <- run_PC_bnlearn(sim_result$data)
# Run Order MCMC algorithm (no need for manual timing)
mcmc_result <- run_order_mcmc(sim_result$data)
# Extract runtime from the MCMC output
runtime_mcmc <- mcmc_result$info$runtimes["total"]
# Evaluate performance (skeleton metrics)
eval_results <- evaluate_skeleton_performance(
true_dag = sim_result$dag,
pc_cpdag = pc_result$learned_cpdag,
mcmc_cpdag = mcmc_result$DAG
)
# Store metrics for PC
results$PC$TPR[i] <- eval_results$PC$TPR
results$PC$FPR[i] <- eval_results$PC$FPR
results$PC$SHD[i] <- eval_results$PC$Skeleton_SHD
# Store metrics for MCMC
results$MCMC$TPR[i] <- eval_results$MCMC$TPR
results$MCMC$FPR[i] <- eval_results$MCMC$FPR
results$MCMC$SHD[i] <- eval_results$MCMC$Skeleton_SHD
results$MCMC$runtime[i] <- runtime_mcmc  # Store MCMC runtime
}
return(results)
}
monte_carlo_results <- run_monte_carlo(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.15)
#Sample from Bayesian Network
source("data_sim.R")
#PC algorithm
source("pc_algorithm.R")
#Order MCMC Algorithm
source("order_mcmc.R")
View(monte_carlo_results)
monte_carlo_results
run_monte_carlo <- function(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.2) {
# Store results in a list
results <- list(
PC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations)),
MCMC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations), runtime = numeric(num_iterations))
)
for (i in 1:num_iterations) {
cat("Running iteration", i, "of", num_iterations, "\n")
# Generate random DAG & sample data
sim_result <- simulate_GBN(num_nodes = num_nodes, num_samples = num_samples, edge_prob = edge_prob)
# Run PC algorithm
pc_result <- run_PC_bnlearn(sim_result$data)
# Run Order MCMC algorithm (no need for manual timing)
mcmc_result <- run_order_mcmc(sim_result$data)
# Extract runtime from the MCMC output
runtime_mcmc <- mcmc_result$info$runtimes["total"]
# Evaluate performance (skeleton metrics)
eval_results <- evaluate_skeleton_performance(
true_dag = sim_result$dag,
pc_cpdag = pc_result$learned_cpdag,
mcmc_cpdag = mcmc_result$DAG
)
# Store metrics for PC
results$PC$TPR[i] <- eval_results$PC$TPR
results$PC$FPR[i] <- eval_results$PC$FPR
results$PC$SHD[i] <- eval_results$PC$Skeleton_SHD
# Store metrics for MCMC
results$MCMC$TPR[i] <- eval_results$MCMC$TPR
results$MCMC$FPR[i] <- eval_results$MCMC$FPR
results$MCMC$SHD[i] <- eval_results$MCMC$Skeleton_SHD
results$MCMC$runtime[i] <- runtime_mcmc  # Store MCMC runtime
}
return(results)
}
monte_carlo_results <- run_monte_carlo(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.15)
monte_carlo_results$MCMC
data_test = simulate_GBN()
data_test = simulate_GBN(num_nodes = 5)
data_test = simulate_GBN(num_nodes = 5, edge_prob = 0.2)
data_test = simulate_GBN(num_nodes = 5, edge_prob = 0.2, num_samples = 100)
mcmc_test = run_order_mcmc(data_test$data)
mcmc_test$info
mcmc_test$info$runtimes
typeof(mcmc_test$info$runtimes)
as.numeric(mcmc_test$info$runtimes["MCMCchain"])
run_monte_carlo <- function(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.2) {
# Store results in a list
results <- list(
PC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations)),
MCMC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations), runtime = numeric(num_iterations))
)
for (i in 1:num_iterations) {
cat("Running iteration", i, "of", num_iterations, "\n")
# Generate random DAG & sample data
sim_result <- simulate_GBN(num_nodes = num_nodes, num_samples = num_samples, edge_prob = edge_prob)
# Run PC algorithm
pc_result <- run_PC_bnlearn(sim_result$data)
# Run Order MCMC algorithm (no need for manual timing)
mcmc_result <- run_order_mcmc(sim_result$data)
# Extract runtime from the MCMC output
runtime_mcmc <-  as.numeric(mcmc_result$info$runtimes["MCMCchain"])
# Evaluate performance (skeleton metrics)
eval_results <- evaluate_skeleton_performance(
true_dag = sim_result$dag,
pc_cpdag = pc_result$learned_cpdag,
mcmc_cpdag = mcmc_result$DAG
)
# Store metrics for PC
results$PC$TPR[i] <- eval_results$PC$TPR
results$PC$FPR[i] <- eval_results$PC$FPR
results$PC$SHD[i] <- eval_results$PC$Skeleton_SHD
# Store metrics for MCMC
results$MCMC$TPR[i] <- eval_results$MCMC$TPR
results$MCMC$FPR[i] <- eval_results$MCMC$FPR
results$MCMC$SHD[i] <- eval_results$MCMC$Skeleton_SHD
results$MCMC$runtime[i] <- runtime_mcmc  # Store MCMC runtime
}
return(results)
}
monte_carlo_results <- run_monte_carlo(num_iterations = 1, num_nodes = 10, num_samples = 500, edge_prob = 0.15)
monte_carlo_results$MCMC
source("monte_carlo.R")
generate_settings_list <- function(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set) {
# Create a data frame of all combinations
settings_df <- expand.grid(
num_samples = num_samples_set,
num_nodes = num_nodes_set,
edge_prob = edge_prob_set,
beta_min = sapply(beta_range_set, function(x) x[1]),
beta_max = sapply(beta_range_set, function(x) x[2])
)
# Convert to a list of lists
settings_list <- apply(settings_df, 1, function(row) {
list(
num_samples = as.numeric(row["num_samples"]),
num_nodes = as.numeric(row["num_nodes"]),
edge_prob = as.numeric(row["edge_prob"]),
beta_range = c(as.numeric(row["beta_min"]), as.numeric(row["beta_max"]))
)
})
return(settings_list)
}
# Define parameter sets
num_nodes_set <- c(5, 10, 25)
num_samples_set <- c(100, 500, 1000)
edge_prob_set <- c(0.1)
beta_range_set <- list(c(0.1, 1), c(1, 3))
# Generate settings list
settings <- generate_settings_list(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set)
View(settings)
# Print a sample of generated settings
print(settings[[1]])  # Example: First setting
generate_named_settings_list <- function(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set) {
# Create a data frame of all combinations
settings_df <- expand.grid(
num_samples = num_samples_set,
num_nodes = num_nodes_set,
edge_prob = edge_prob_set,
beta_min = sapply(beta_range_set, function(x) x[1]),
beta_max = sapply(beta_range_set, function(x) x[2])
)
# Convert to a named list of lists
settings_list <- list()
for (i in 1:nrow(settings_df)) {
setting_name <- paste0(
"nodes_", settings_df$num_nodes[i],
"_samples_", settings_df$num_samples[i],
"_edge_", settings_df$edge_prob[i],
"_beta_", settings_df$beta_min[i], "_", settings_df$beta_max[i]
)
settings_list[[setting_name]] <- list(
num_samples = settings_df$num_samples[i],
num_nodes = settings_df$num_nodes[i],
edge_prob = settings_df$edge_prob[i],
beta_range = c(settings_df$beta_min[i], settings_df$beta_max[i])
)
}
return(settings_list)
}
# Generate list of all combinations (settings) we use
settings_list <- generate_settings_list(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set)
View(settings_list)
generate_named_settings_list <- function(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set) {
# Create a data frame of all combinations
settings_df <- expand.grid(
num_samples = num_samples_set,
num_nodes = num_nodes_set,
edge_prob = edge_prob_set,
beta_min = sapply(beta_range_set, function(x) x[1]),
beta_max = sapply(beta_range_set, function(x) x[2])
)
# Convert to a named list of lists
settings_list <- list()
for (i in 1:nrow(settings_df)) {
setting_name <- paste0(
"nodes_", settings_df$num_nodes[i],
"_samples_", settings_df$num_samples[i],
"_edge_", settings_df$edge_prob[i],
"_beta_", settings_df$beta_min[i], "_", settings_df$beta_max[i]
)
settings_list[[setting_name]] <- list(
num_samples = settings_df$num_samples[i],
num_nodes = settings_df$num_nodes[i],
edge_prob = settings_df$edge_prob[i],
beta_range = c(settings_df$beta_min[i], settings_df$beta_max[i])
)
}
return(settings_list)
}
# Define parameter sets
num_nodes_set <- c(5, 10, 25)
num_samples_set <- c(100, 500, 1000)
edge_prob_set <- c(0.1)
beta_range_set <- list(c(0.1, 1), c(1, 3))
# Generate list of all combinations (settings) we use
settings_list <- generate_settings_list(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set)
settings_list
settings_list[1]
generate_settings_list <- function(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set) {
# Create a data frame of all combinations
settings_df <- expand.grid(
num_samples = num_samples_set,
num_nodes = num_nodes_set,
edge_prob = edge_prob_set,
beta_min = sapply(beta_range_set, function(x) x[1]),
beta_max = sapply(beta_range_set, function(x) x[2])
)
# Convert to a named list of lists
settings_list <- list()
for (i in 1:nrow(settings_df)) {
setting_name <- paste0(
"nodes_", settings_df$num_nodes[i],
"_samples_", settings_df$num_samples[i],
"_edge_", settings_df$edge_prob[i],
"_beta_", settings_df$beta_min[i], "_", settings_df$beta_max[i]
)
settings_list[[setting_name]] <- list(
num_samples = settings_df$num_samples[i],
num_nodes = settings_df$num_nodes[i],
edge_prob = settings_df$edge_prob[i],
beta_range = c(settings_df$beta_min[i], settings_df$beta_max[i])
)
}
return(settings_list)
}
# Generate list of all combinations (settings) we use
settings_list <- generate_settings_list(num_samples_set, num_nodes_set, edge_prob_set, beta_range_set)
settings_list
names(settings_list)
run_monte_carlo <- function(num_iterations = 100, num_nodes = 10, num_samples = 500, edge_prob = 0.2, beta_range= c(1,3)) {
# Store results in a list
results <- list(
PC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations)),
MCMC = list(TPR = numeric(num_iterations), FPR = numeric(num_iterations), SHD = numeric(num_iterations), runtime = numeric(num_iterations))
)
for (i in 1:num_iterations) {
cat("Running iteration", i, "of", num_iterations, "\n")
# Generate random DAG & sample data
sim_result <- simulate_GBN(num_nodes = num_nodes, num_samples = num_samples, edge_prob = edge_prob, beta_range = beta_range)
# Run PC algorithm
pc_result <- run_PC_bnlearn(sim_result$data)
# Run Order MCMC algorithm (no need for manual timing)
mcmc_result <- run_order_mcmc(sim_result$data)
# Extract runtime from the MCMC output
runtime_mcmc <-  as.numeric(mcmc_result$info$runtimes["MCMCchain"])
# Evaluate performance (skeleton metrics)
eval_results <- evaluate_skeleton_performance(
true_dag = sim_result$dag,
pc_cpdag = pc_result$learned_cpdag,
mcmc_cpdag = mcmc_result$DAG
)
# Store metrics for PC
results$PC$TPR[i] <- eval_results$PC$TPR
results$PC$FPR[i] <- eval_results$PC$FPR
results$PC$SHD[i] <- eval_results$PC$Skeleton_SHD
# Store metrics for MCMC
results$MCMC$TPR[i] <- eval_results$MCMC$TPR
results$MCMC$FPR[i] <- eval_results$MCMC$FPR
results$MCMC$SHD[i] <- eval_results$MCMC$Skeleton_SHD
results$MCMC$runtime[i] <- runtime_mcmc  # Store MCMC runtime
}
return(results)
}
run_monte_carlo_across_settings <- function(num_iterations = 100, settings_list) {
# Initialize results list
results <- list()
for (setting_name in names(settings_list)) {
# Extract parameter values from settings list
setting <- settings_list[[setting_name]]
num_nodes <- setting$num_nodes
num_samples <- setting$num_samples
edge_prob <- setting$edge_prob
beta_range <- setting$beta_range
cat("Running Monte Carlo for", setting_name, "\n")
# Run Monte Carlo for this setting
mc_results <- run_monte_carlo(
num_iterations = num_iterations,
num_nodes = num_nodes,
num_samples = num_samples,
edge_prob = edge_prob
)
# Store results under the appropriate name
results[[setting_name]] <- mc_results
}
return(results)
}
settings_list
final_sim_res= run_monte_carlo_across_settings(num_iterations = 100, settings_list = settings_list)
final_sim_res= run_monte_carlo_across_settings(num_iterations = 100, settings_list = settings_list)
final_sim_res= run_monte_carlo_across_settings(num_iterations = 100, settings_list = settings_list)
final_sim_res= run_monte_carlo_across_settings(num_iterations = 100, settings_list = settings_list)
################
evaluate_skeleton_performance <- function(true_dag, pc_cpdag, mcmc_cpdag) {
# Convert True DAG (bnlearn) to adjacency matrix
if (inherits(true_dag, "bn")) {
true_skeleton <- as.matrix(amat(true_dag))
} else {
true_skeleton <- as.matrix(true_dag)
}
# Convert PC CPDAG (bnlearn) to adjacency matrix
if (inherits(pc_cpdag, "bn")) {
pc_skeleton <- as.matrix(amat(pc_cpdag))
} else {
pc_skeleton <- as.matrix(pc_cpdag)
}
# Debug: Print the class and structure of MCMC CPDAG before conversion
print(paste("Class of MCMC CPDAG:", class(mcmc_cpdag)))
print(str(mcmc_cpdag))  # Print structure to see if it's in an unexpected format
# Convert MCMC CPDAG (BiDAG) to adjacency matrix
if (inherits(mcmc_cpdag, "matrix")) {
mcmc_skeleton <- mcmc_cpdag
} else if (inherits(mcmc_cpdag, "dgCMatrix") || inherits(mcmc_cpdag, "dtCMatrix")) {
mcmc_skeleton <- as.matrix(mcmc_cpdag)
} else {
stop("MCMC CPDAG format not recognized. Expected a matrix, dgCMatrix, or dtCMatrix.")
}
# Convert all graphs to undirected skeletons
true_skeleton[true_skeleton > 0] <- 1
pc_skeleton[pc_skeleton > 0] <- 1
mcmc_skeleton[mcmc_skeleton > 0] <- 1
# Number of edges in true DAG
num_true_edges <- sum(true_skeleton) / 2  # Divide by 2 since undirected edges are counted twice
# Function to compute TPR, FPR, and SHD
compute_metrics <- function(estimated_skeleton, true_skeleton) {
TP <- sum(estimated_skeleton & true_skeleton) / 2  # True Positives
FP <- sum(estimated_skeleton & !true_skeleton) / 2  # False Positives
TPR <- TP / num_true_edges  # True Positive Rate
FPR <- FP / num_true_edges  # False Positive Rate
skeleton_shd <- sum((true_skeleton != estimated_skeleton) & (true_skeleton + estimated_skeleton > 0)) / 2
return(list(TPR = TPR, FPR = FPR, Skeleton_SHD = skeleton_shd))
}
# Compute metrics for PC and MCMC
pc_metrics <- compute_metrics(pc_skeleton, true_skeleton)
mcmc_metrics <- compute_metrics(mcmc_skeleton, true_skeleton)
# Return results
return(list(PC = pc_metrics, MCMC = mcmc_metrics))
}
final_sim_res= run_monte_carlo_across_settings(num_iterations = 100, settings_list = settings_list)
################
evaluate_skeleton_performance <- function(true_dag, pc_cpdag, mcmc_cpdag) {
# Convert True DAG (bnlearn) to adjacency matrix
if (inherits(true_dag, "bn")) {
true_skeleton <- as.matrix(amat(true_dag))
} else {
true_skeleton <- as.matrix(true_dag)
}
# Convert PC CPDAG (bnlearn) to adjacency matrix
if (inherits(pc_cpdag, "bn")) {
pc_skeleton <- as.matrix(amat(pc_cpdag))
} else {
pc_skeleton <- as.matrix(pc_cpdag)
}
# Convert MCMC CPDAG (BiDAG) to adjacency matrix
if (inherits(mcmc_cpdag, "matrix")) {
mcmc_skeleton <- mcmc_cpdag
} else if (inherits(mcmc_cpdag, "dgCMatrix") || inherits(mcmc_cpdag, "dtCMatrix")) {
mcmc_skeleton <- as.matrix(mcmc_cpdag)
} else if (inherits(mcmc_cpdag, "ddiMatrix")) {
mcmc_skeleton <- as.matrix(mcmc_cpdag)  # Convert diagonal matrix to standard matrix
} else {
stop("MCMC CPDAG format not recognized. Expected a matrix, dgCMatrix, dtCMatrix, or ddiMatrix.")
}
# Convert all graphs to undirected skeletons
true_skeleton[true_skeleton > 0] <- 1
pc_skeleton[pc_skeleton > 0] <- 1
mcmc_skeleton[mcmc_skeleton > 0] <- 1
# Number of edges in true DAG
num_true_edges <- sum(true_skeleton) / 2  # Divide by 2 since undirected edges are counted twice
# Function to compute TPR, FPR, and SHD
compute_metrics <- function(estimated_skeleton, true_skeleton) {
TP <- sum(estimated_skeleton & true_skeleton) / 2  # True Positives
FP <- sum(estimated_skeleton & !true_skeleton) / 2  # False Positives
TPR <- TP / num_true_edges  # True Positive Rate
FPR <- FP / num_true_edges  # False Positive Rate
skeleton_shd <- sum((true_skeleton != estimated_skeleton) & (true_skeleton + estimated_skeleton > 0)) / 2
return(list(TPR = TPR, FPR = FPR, Skeleton_SHD = skeleton_shd))
}
# Compute metrics for PC and MCMC
pc_metrics <- compute_metrics(pc_skeleton, true_skeleton)
mcmc_metrics <- compute_metrics(mcmc_skeleton, true_skeleton)
# Return results
return(list(PC = pc_metrics, MCMC = mcmc_metrics))
}
final_sim_res= run_monte_carlo_across_settings(num_iterations = 3, settings_list = settings_list)
final_sim_res
final_sim_res$nodes_5_samples_100_edge_0.1_beta_0.1_1
final_sim_res$nodes_10_samples_1000_edge_0.1_beta_0.1_1$PC
final_sim_res$nodes_10_samples_1000_edge_0.1_beta_0.1_1$PC$TPR
#Source Function
#Sample from Bayesian Network
source("data_sim.R")
#PC algorithm
source("pc_algorithm.R")
#Order MCMC Algorithm
source("order_mcmc.R")
n
